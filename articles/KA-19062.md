---
title: AEM 6.x에서 문제가 보고될 때 SegmentNotFoundException을 디버깅하는 방법
description: 설명
solution: Experience Manager
product: Experience Manager
applies-to: Experience Manager
keywords: KCS
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Akash Kapoor
article-created-date: 4/3/2022 7:14:43 PM
article-published-by: Akash Kapoor
article-published-date: 4/3/2022 7:14:58 PM
version-number: 4
article-number: KA-19062
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=63dd174c-82b3-ec11-983f-000d3a5d09d6
exl-id: 0580f08b-a72c-45ec-817e-e850d2360e9d
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '1214'
ht-degree: 0%

---

# AEM 6.x에서 문제가 보고될 때 SegmentNotFoundException을 디버깅하는 방법

## 설명


<b>AEM 6.x에서 문제가 보고될 때 SegmentNotFoundException을 디버깅하는 방법</b>

A <b>SegmentNotFoundException</b> 오류 로그에서 는 누군가 여전히 액세스하려고 하지만 세그먼트가 더 이상 존재하지 않음을 의미합니다. 이에 대한 크게 세 가지 다른 근본 원인이 있습니다. 세그먼트가 수동 개입(예: rm -rf /)으로 제거되었거나, 세그먼트가 개정 가비지 수집에 의해 제거되었거나, 코드의 일부 버그로 인해 세그먼트를 찾을 수 없습니다.

로그에 다음과 같은 예외가 있을 수 있습니다.

...

org.apache.jackrabbit.oak.segment.SegmentNotFoundException: org.apache.jackrabbit.oak.segment.file.FileStore$8.call(FileStore.java:602)의 org.apache.jackrabbit.oak.segment.file.FileStore$8.call(FileStore.java:542)에서 세그먼트 d2c720c4-c146-4ab1-ac3777-546-4a3c33f를 찾을 수 없습니다(org.Jackrabbit.get.get.segment.get.get.gment.getGment.get.Jackrabbit.gment.get.get.get.getJavaFile.segment.gment.getFileFileFileFile.getGment.getFile.getFile.segment.getFileFile.org.apache.jackrabbit.oak.segment.file.FileStore.readSegment(FileStore.java:542) at org.apache.jackrabbit.segment.SegmentId.getSegment(SegmentId.java:125) at.org.apache.jackrabbit.segment.Record.getSegment(Record.java:70) at.org.jackrabbit.Map.Record.JavaRecord.4.JavaMapRecord.4JavaList4 at org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:433) at org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:391) at.org.apache.oak.segment.SegmentNodeState.compareOnApacheBaseState(SegmentNodeState.java:608) at.org.jackrabbit.Jackrabbit.Commit.Commit.AutEditorDiffEditorDiffDiffEditor(SubnodeCommit.DiffEditorEditorSubset.EditorEditorEditorChanged.EditorEditorEditor.EditorEditorEditorEditorOrg.apache.jackrabbit.oak.segment.MapRecord$3.childNodeChanged(MapRecord.java:442) at org.apache.jackrabbit.segment.MapRecord.compare(MapRecord.java:490) at.apache.jackrabbit.segment.MapRecord.compare(MapRecord.java:433) at.org.apache.Jackrabbit.Java.Oak.Data.Segment.Oak.NodeBase.OakNodeNodeCompareBase.Oak.NodeOak.OakNodeCompareCompareCompareCompareCompareNodeOak.Oak.NodeCompareCompareorg.apache.jackrabbit.oak.spi.commit.EditorDiff.process(EditorDiff.java:52) at org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdate.updateIndex(AsyncIndexUpdate.java:695) at org.apache.jackrabbit.plugins.index.AsyncIndexUpdate.runWhenWhenAllowed(JavaUpdate.org.atJava5)에서 state(JavasyncIndexUpdateIndexUpdate4)(JavaIndexIndexUpdateIndexIndexIndex5) org.quartz.core.JobRunShell.run(JobRun.java:202)의 org.apache.sling.commons.scheduler.impl.QuartzJobExecutor.execute(QuartzJobExecutor.java:118) at.apache.jackrabbit.oak.plugins.index.run.asyncIndexUpdate.run(AsyncIndexUpdate.java:402)(JavaConcurrentThreadThreadThreadThreadWorker(Run.ThreadThreadHostRun) java.lang.Thread.run(Thread.java:745)의 java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)(Thread.java:745)의 poolExecutor.java:1142)

...


## 해상도


다음 두 가지 방법으로 문제를 해결하고 A 섹션과 B 섹션에 설명된 리포지토리에서 불일치를 제거할 수 있습니다.

<b>A. 세그먼트 저장소의 양호한 것으로 알려진 마지막 수정 버전으로 되돌립니다.</b>

먼저 간단한 Oak 설치 및 oak 관련 작업을 수행하는 데 필요한 모든 것을 포함하는 실행 가능한 jar1인 oak 실행 도구를 사용해야 합니다.

oak-run의 검사 실행 모드를 사용하여 세그먼트 저장소의 양호한 것으로 알려진 마지막 수정 버전을 확인할 수 있습니다.  손상된 세그먼트 저장소를 수동으로 최근의 양호한 수정 버전으로 되돌리는 데 사용할 수 있습니다.

*주의: 이 프로세스는 시스템의 데이터를 이전 시점으로 롤백합니다.  시스템의 변경 사항을 유실하지 않으려면 대신 아래의 옵션 B를 시도할 수 있습니다.*

확인 및 복원을 수행하려면 다음을 수행합니다.

1. oak 코어 버전과 일치하는 oak-run 버전을 [https://mvnrepository.com/artifact/org.apache.jackrabbit/oak-run](https://mvnrepository.com/artifact/org.apache.jackrabbit/oak-run)
2. 손상된 세그먼트 저장소를 최근의 양호한 상태 변경 내용을 CQ의 작업 디렉토리(crx-quickstartfolder가 포함된 디렉토리)로 되돌리려면 의 모든 파일을 백업합니다./crx-quickstart/repository/segmentstore/
3. 일관성 검사 실행, java -Xmx6000m -jar oak-run-\*.jar check —bin=-1 /path/to/crx-quickstart/repository/segmentstore 일관성 있는 항목을 찾을 때까지 수정 내용을 역순으로 검색합니다. 다음과 같은 메시지를 찾습니다. main INFO o.a.j.o.p.s.t.ConsistencyChecker - 최신 버전의 afdb922d-ba53-4a1b-aa1b-1cb044b535cf:234880
4. 을 편집하여 리포지토리를 이 수정 버전으로 되돌립니다./crx-quickstart/repository/segmentstore/journal.log 및 최신 양호한 수정 버전이 포함된 라인 뒤에 있는 모든 라인을 삭제합니다.
5. 모두 제거 ./crx-quickstart/repository/segmentstore/\*.bak 파일을 제거합니다.
6. 체크포인트 정리를 실행하여 분리된 체크포인트를 다음 명령으로 제거합니다. java -Xmx6000m -jar oak-run-\*.jar 체크포인트 /path/to/crx-quickstart/repository/segmentstore rm-unreferenced
7. 마지막으로 리포지토리를 압축합니다. java -Xmx6000m -jar oak-run-\*.jar compact /path/to/crx-quickstart/repository/segmentstore/




*oak 실행 검사에서 올바른 개정을 찾을 수 없고 check 명령을 실행하는 동안 &quot;ConsistencyChecker - 양호한 수정 버전이 없음&quot;이 표시되는 경우가 있을 수 있습니다.*
<b>일관성 검사에서 &quot;ConsistencyChecker - 양호한 수정 없음&quot;이 발생할 때 손상을 수정하는 방법</b>


<b>B. 손상된 노드를 수동으로 제거합니다.</b>

AEM에서 FileDatastore가 구성되지 않은 TarMK 설정과 바이너리에 손상이 있는 상황에서 다음을 수행할 수 있습니다.

\*주 n:\*아래 절차는 고급 사용자를 위한 것입니다.  손상된 노드를 삭제할 때는 시스템 노드(예: /home, /jcr:system 등)가 아닌지 확인해야 합니다.  또는 시스템 노드인 경우 복원할 수 있는지 확인해야 합니다.  확실하지 않은 경우 여기에 설명된 단계에 대한 도움이 필요하면 AEM 고객 지원 팀에 문의하십시오.



1. AEM을 중지합니다.
2. Oak 실행 콘솔을 사용하고 childCount groovy 스크립트를 로드하여 세그먼트 저장소에서 손상된 노드를 식별합니다.


oak-run 콘솔 셸을 로드합니다.

java -jar oak-run-\*.jar console crx-quickstart/repository/segmentstore

셸에서 아래의 두 명령을 실행하여 스크립트를 로드하고 실행합니다.

https://gist.githubusercontent.com/stillalex/e7067bcb86c89bef66c8/raw/d7a5a9b839c3bb0ae5840252022f871fd38374d3/childCount.groovy 로드

countNodes(session.workingNode)

이렇게 하면 손상된 노드의 경로를 나타내는 다음 출력이 표시됩니다.

21년:21:42.029 주 오류 o.j.o.p.segmentTracker - 세그먼트를 찾을 수 없음: 63ae05a4-b506-445c-baa2-cfa1b13b6e2f. 생성 날짜 델타는 3ms입니다.

경고 노드 /content/dam/test.txt/jcr:content/renditions/original/jcr:content 를 읽을 수 없습니다.

문제가 이진 속성에 연결되어 있고 childCount groovy 스크립트가 손상된 노드를 찾을 수 없는 경우가 있습니다.  이러한 경우 다음 명령을 대신 사용할 수 있습니다. 이 명령을 사용하면 순회 중에 발생한 모든 바이너리에 대해 처음 1024바이트를 읽을 수 있습니다. 이 명령은 속도가 느리며 위의 명령이 예상 결과를 반환하지 않는 경우에만 사용해야 합니다.

countNodes(session.workingNode,true)

3. rmNodes.groovy를 사용하여 마지막 명령의 출력에 나열된 식별된 손상된 노드를 모두 제거합니다.

아래 명령을 사용하여 oak-run 콘솔 셸을 로드합니다.

java -jar oak-run-\*.jar console crx-quickstart/repository/segmentstore

groovy 스크립트를 로드합니다.

:load

https://gist.githubusercontent.com/stillalex/43c49af065e3dd1fd5bf/raw/9e726a59f75b46e7b474f7ac763b0888d5a3f0c3/rmNode.groovy

rmNode 명령을 실행하여 손상된 노드를 제거하고 /path/to/corrupt/node를 제거해야 하는 손상된 노드의 경로로 바꿉니다.

rmNode(session, &quot;/path/to/corrupt/node&quot;)

손상된 노드 경로가 2단계에서 얻은 경로인 경우, 예를 들면 다음과 같습니다. &quot;/content/dam/test.txt/jcr:content/renditions/original/jcr:content/&quot; 참고: oak-run.jar 버전 1.6.13 이상을 사용할 때 다음과 같은 오류가 발생하면 —read-write JVM 매개 변수를 설정하십시오.

/ rmNode(session,&quot;/path/to/corrupt/node&quot;) 노드 /path/to/corrupt/node ERROR java.lang.UnsupportedOperationException:    org.apache.jackrabbit.oak.segment.SegmentWriterBuilder$1.execute (SegmentWriterBuilder.java:171) at org.apache.jackrabbit.segment.SegmentWriter.writeNode(SegmentWriter.java:318) at.apache.jackrabbit.segment.segmentNodeBuilder.getNodeState (SegmentNodeBuilder.java:11111.org.Apache Jackrabbit.gment.gmentGment의 읽기 전용 저장소에 쓸 수 없습니다. org.apache.jackrabbit.oak.segment.SegmentNodeStore.merge (SegmentNodeStore.java:33) at org.apache.jackrabbit.oak.spi.state.NodeStore$merge.call (알 수 없는 소스)의 store$Commit.init (SegmentNodeStore.java:581)(groovysh_evaluate:11)

4. 2단계에서 찾은 모든 노드에 대해 3단계를 반복합니다.

위의 rmNode 명령은 손상된 경로에 대해 true를 반환해야 합니다. 이는 경로를 삭제했음을 의미합니다. 해당 경로에서 rmNode 명령을 다시 실행하여 손상된 세 개의 경로가 삭제되었는지 확인하십시오. 다음에 실행하면 false를 반환해야 합니다.

리포지토리에 동일한 경로가 여전히 표시된다면 패치가 적용된 oak-run jar 버전(예: oak-run-1.2.18-NPR-17596)을 사용하십시오.

패치가 적용된 Oak-run Jar 버전은 어떤 작업을 수행합니까?

이 jar 버전은 압축 시 읽을 수 없는 바이너리를 건너뛰고 0바이트 바이너리로 바꾸고 예외 및 syserr 경로를 로깅합니다. 이렇게 압축된 리포지토리는 노드 수 스크립트인 oak-run check를 전달해야 하며 패치가 적용되지 않은 oak-run을 사용하여 다시 압축할 수도 있어야 합니다.

5. 아래를 사용하여 체크포인트를 나열하여 체크포인트 정리를 수행합니다. 체크포인트가 두 개 이상 있으면 정리합니다.

nohup java -Xmx4096m -jar oak-run-1.2.18.jar 체크포인트 /app/AEM6/author/crx-quickstart/repository/segmentstore rm-allnohup.out 및

6. 오프라인 압축을 실행합니다.  오프라인 압축을 실행하는 방법을 모를 경우 다음을 참조하십시오 [여기](https://gist.github.com/andrewmkhoury/0b1fe4d8b619178ff87b).

7. 서버를 시작하여 색인화가 완료될 때까지 기다립니다.
