---
title: AEM 6.x에서 문제가 보고될 때 SegmentNotFoundException을 디버깅하는 방법
description: 설명
solution: Experience Manager
product: Experience Manager
applies-to: Experience Manager
keywords: KCS, Experience Manager, 오류, 세그먼트,oak
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Victoria Barnato
article-created-date: 3/10/2023 2:20:24 AM
article-published-by: Victoria Barnato
article-published-date: 3/10/2023 9:05:28 PM
version-number: 6
article-number: KA-19062
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=08bf921c-eabe-ed11-83ff-6045bd006d92
exl-id: 0580f08b-a72c-45ec-817e-e850d2360e9d
source-git-commit: a0647c21bdff145be0cea2932ed31f8c90fa28e8
workflow-type: tm+mt
source-wordcount: '894'
ht-degree: 17%

---

# AEM 6.x에서 문제가 보고될 때 SegmentNotFoundException을 디버깅하는 방법

## 설명 {#description}

<br>문제<br><br>
오류 로그에 다음 예와 같이 SegmentNotFound 예외가 표시됩니다.

`org.apache.jackrabbit.oak.segment.SegmentNotFoundException: Segment d2c720c4-c146-4ab1-ac37-542aad93c33f not found at org.apache.jackrabbit.oak.segment.file.FileStore$8.call(FileStore.java:602) at org.apache.jackrabbit.oak.segment.file.FileStore$8.call(FileStore.java:542) at org.apache.jackrabbit.oak.segment.SegmentCache.getSegment(SegmentCache.java:95) at org.apache.jackrabbit.oak.segment.file.FileStore.readSegment(FileStore.java:542) at org.apache.jackrabbit.oak.segment.SegmentId.getSegment(SegmentId.java:125) at org.apache.jackrabbit.oak.segment.Record.getSegment(Record.java:70) at org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:424) at org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:433) at org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:391) at org.apache.jackrabbit.oak.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:608) at org.apache.jackrabbit.oak.spi.commit.EditorDiff.childNodeChanged(EditorDiff.java:148) at org.apache.jackrabbit.oak.segment.MapRecord$3.childNodeChanged(MapRecord.java:442) at org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:490) at org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:433) at org.apache.jackrabbit.oak.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:608) at org.apache.jackrabbit.oak.spi.commit.EditorDiff.process(EditorDiff.java:52) at org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdate.updateIndex(AsyncIndexUpdate.java:695) at org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdate.runWhenPermitted(AsyncIndexUpdate.java:543) at org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdate.run(AsyncIndexUpdate.java:402) at org.apache.sling.commons.scheduler.impl.QuartzJobExecutor.execute(QuartzJobExecutor.java:118) at org.quartz.core.JobRunShell.run(JobRunShell.java:202) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745)`

<br><br>환경<br><br>
Adobe Experience Manager 6.x


## 해결 방법 {#resolution}

원인<br>
오류 로그에 있는 SegmentNotFoundException은 다른 사용자가 여전히 액세스하려고 하지만 세그먼트가 더 이상 존재하지 않음을 의미합니다. 이에 대한 크게 세 가지 다른 근본 원인이 있습니다. 세그먼트가 수동 개입(예: rm -rf /)으로 제거되었거나, 세그먼트가 개정 가비지 수집에 의해 제거되었거나, 코드의 일부 버그로 인해 세그먼트를 찾을 수 없습니다.
<br>해결할 단계<br>
문제를 수정하고 리포지토리에서 불일치를 제거하는 두 가지 방법이 있습니다

<b>마지막으로 알려진 세그먼트 스토어 수정 버전으로 되돌리기.</b>

먼저 간단한 Oak 설치 및 oak 관련 작업을 수행하는 데 필요한 모든 것을 포함하는 실행 가능한 jar1인 oak 실행 도구를 사용합니다.

oak-run의 검사 실행 모드를 사용하여 세그먼트 저장소의 양호한 것으로 알려진 마지막 수정 버전을 확인할 수 있습니다.  수동으로 손상된 세그먼트 스토어를 최신 버전으로 되돌리는 데 사용할 수 있습니다.

*주의: 이 프로세스는 시스템의 데이터를 이전 시점으로 롤백합니다.  시스템에서 변경 사항의 손실을 방지하려면 대신 아래 옵션 B를 시도할 수 있습니다.*

확인 및 복원하려면

1. [https://mvnrepository.com/artifact/org.apache.jackrabbit/oak-run](https://mvnrepository.com/artifact/org.apache.jackrabbit/oak-run)에서 Oak 코어 버전과 일치하는 oak-run 버전을 다운로드합니다.
2. 손상된 세그먼트 저장소를 최근의 양호한 상태로 되돌리려면 CQ의 작업 디렉토리(crx-quickstartfolder가 포함된 디렉토리)로 변경하고 의 모든 파일을 백업합니다./crx-quickstart/repository/segmentstore/
3. 일관성 검사 실행, java -Xmx6000m -jar oak-run-\*.jar check —bin=-1 /path/to/crx-quickstart/repository/segmentstore 일관성 있는 항목을 찾을 때까지 수정 내용을 역순으로 검색합니다. 다음과 같은 메시지를 찾습니다.


   ```
   main INFO o.a.j.o.p.s.f.t.ConsistencyChecker - Found latest good revision afdb922d-ba53-4a1b-aa1b-1cb044b535cf:234880
   ```

4. 편집하여 저장소를 이 수정 버전으로 되돌립니다 ./crx-quickstart/repository/segmentstore/journal.log 및 최신 양호한 수정 버전이 포함된 라인 뒤에 있는 모든 라인을 삭제합니다.
5. 모두 제거 ./crx-quickstart/repository/segmentstore/\*.bak 파일을 제거합니다.
6. 체크포인트 정리 를 실행하여 다음 명령을 사용하여 분리된 체크포인트를 제거합니다.


   ```
   java -Xmx6000m -jar oak-run-*.jar checkpoints /path/to/crx-quickstart/repository/segmentstore rm-unreferenced
   ```

7. 마지막으로 저장소 압축:


   ```
   java -Xmx6000m -jar oak-run-*.jar compact /path/to/crx-quickstart/repository/segmentstore/
   ```


*oak 실행 검사에서 올바른 개정을 찾을 수 없고 check 명령을 실행하는 동안 &quot;ConsistencyChecker - No good revision found&quot;가 표시되는 경우가 있을 수 있습니다.*
<b>일관성 검사에서 &quot;ConsistencyChecker - 양호한 수정 없음&quot;이 발생할 때 손상을 수정하는 방법</b>
<b>손상된 노드를 수동으로 제거합니다.</b>

AEM, FileDatastore가 구성되지 않은 TarMK 설정 및 바이너리에 손상이 있는 상황에서 다음을 수행할 수 있습니다.

<b>주의</b>: 아래 절차는 고급 사용자를 위한 것입니다.  손상된 노드를 삭제할 때 시스템 노드(예: /home, /jcr:system 등)가 아닌지 확인해야 합니다.  시스템 노드인 경우 복원할 수 있는지 확인해야 합니다.  확실하지 않은 경우 여기에 설명된 단계에 대한 도움이 필요하면 AEM 고객 지원 팀에 문의하십시오.

1. AEM을 중지합니다.
2. Oak 실행 콘솔을 사용하고 childCount groovy 스크립트를 로드하여 세그먼트 저장소에서 손상된 노드를 식별합니다.

   oak-run 콘솔 셸 로드:


   ```
   java -jar oak-run-*.jar console crx-quickstart/repository/segmentstore
   ```



   셸에서 아래 두 명령을 실행하여 스크립트를 로드하고 실행합니다.


   ```
   :load https://gist.githubusercontent.com/stillalex/e7067bcb86c89bef66c8/raw/d7a5a9b839c3bb0ae5840252022f871fd38374d3/childCount.groovy
   
   countNodes(session.workingNode)
   ```



   이렇게 하면 손상된 노드의 경로를 나타내는 다음 출력이 표시됩니다.


   ```
   21:21:42.029 main ERROR o.a.j.o.p.segment.SegmentTracker - Segment not found: 63ae05a4-b506-445c-baa2-cfa1b13b6e2f. Creation date delta is 3 ms.
   warning unable to read node /content/dam/test.txt/jcr:content/renditions/original/jcr:content
   ```



   문제가 이진 속성에 연결되어 있고 childCount groovy 스크립트가 손상된 노드를 찾을 수 없는 경우도 있습니다.  이러한 경우 대신 다음 명령을 사용할 수 있습니다. 이 명령을 사용하면 순회 중에 발생한 모든 바이너리에 대해 처음 1024바이트를 읽을 수 있습니다. 이 명령은 속도가 느려지며 위의 명령이 예상 결과를 반환하지 않는 경우에만 사용해야 합니다.


   ```
   countNodes(session.workingNode,true)
   ```

3. rmNodes.groovy를 사용하여 마지막 명령의 출력에 나열된 식별된 손상된 노드를 모두 제거합니다. 아래 명령을 사용하여 oak-run 콘솔 셸을 로드합니다.


   ```
   java -jar oak-run-*.jar console crx-quickstart/repository/segmentstore
   ```



   Groovy 스크립트 로드:


   ```
   :load
   https://gist.githubusercontent.com/stillalex/43c49af065e3dd1fd5bf/raw/9e726a59f75b46e7b474f7ac763b0888d5a3f0c3/rmNode.groovy
   ```



   rmNode 명령을 실행하여 손상된 노드를 제거하고 /path/to/corrupt/node를 제거해야 하는 손상된 노드의 경로로 바꿉니다.


   ```
   rmNode(session, "/path/to/corrupt/node")
   ```



   여기서 손상된 노드 경로는 2단계에서 얻은 경로입니다(예: &quot;/content/dam/test.txt/jcr:content/renditions/original/jcr:content/&quot;

   참고: oak-run.jar 버전 1.6.13 이상을 사용할 때 다음과 같은 오류가 발생하면 —read-write JVM 매개 변수를 설정하십시오.


   ```
   / rmNode(session,"/path/to/corrupt/node")    Removing node /path/to/corrupt/node    ERROR java.lang.UnsupportedOperationException:    Cannot write to read-only store    at org.apache.jackrabbit.oak.segment.SegmentWriterBuilder$1.execute (SegmentWriterBuilder.java:171)    at org.apache.jackrabbit.oak.segment.SegmentWriter.writeNode (SegmentWriter.java:318)    at org.apache.jackrabbit.oak.segment.SegmentNodeBuilder.getNodeState (SegmentNodeBuilder.java:111)    at org.apache.jackrabbit.oak.segment.SegmentNodeStore$Commit.init (SegmentNodeStore.java:581)    at org.apache.jackrabbit.oak.segment.SegmentNodeStore.merge (SegmentNodeStore.java:333)    at org.apache.jackrabbit.oak.spi.state.NodeStore$merge.call (Unknown Source)    at groovysh_evaluate.rmNode (groovysh_evaluate:11)
   ```

4. 2단계에 발견된 모든 노드에 대해 3단계를 반복합니다



   위의 rmNode 명령은 손상된 경로에 대해 true를 반환해야 합니다. 이는 경로를 삭제했음을 의미합니다. 해당 경로에서 rmNode 명령을 다시 실행하여 손상된 세 개의 경로가 삭제되었는지 확인하십시오. false를 반환하는 경우 실행합니다.
동일한 경로가 리포지토리에 남아 있는 것을 발견하면 <b>패치가 적용된 oak-run jar 버전(예: oak-run-1.2.18-NPR-17596)</b>. 이 jar 버전은 압축 시 읽을 수 없는 바이너리를 건너뛰고 0바이트 바이너리로 바꾸고 예외 및 시스템 경로를 로깅합니다. 그런 다음 압축된 리포지토리는 oak-run check와 노드 수 스크립트를 전달해야 하며, 패치가 적용되지 않은 oak-run을 사용하여 다시 압축할 수도 있어야 합니다.
5. 아래 체크포인트를 나열하여 체크포인트 정리를 수행합니다. 체크포인트가 두 개 이상 있으면 정리합니다.

   ```
   nohup java -Xmx4096m -jar oak-run-1.2.18.jar checkpoints /app/AEM6/author/crx-quickstart/repository/segmentstore rm-allnohup.out &
   ```

6. 오프라인 압축을 실행합니다.  오프라인 압축을 실행하는 방법을 모를 경우 다음을 참조하십시오 [여기](https://gist.github.com/andrewmkhoury/0b1fe4d8b619178ff87b).
7. 인덱싱이 완료될 때까지 서버를 시작합니다.
