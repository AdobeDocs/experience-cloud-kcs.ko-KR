---
title: CAMPAIGN CLASSIC - [!UICONTROL 증분 쿼리] 새 레코드 대신 모든 레코드 선택
description: 설명
solution: Campaign
product: Campaign
applies-to: Campaign Classic
keywords: KCS
resolution: Resolution
internal-notes: Ticket = TK197178
bug: true
article-created-by: Marta Zator
article-created-date: 5/10/2022 9:47:14 AM
article-published-by: Marta Zator
article-published-date: 5/10/2022 9:51:21 AM
version-number: 2
article-number: KA-15190
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ad8bd527-46d0-ec11-a7b5-00224809c101
exl-id: f3dee0a7-8047-4949-9162-de95ba07fa7f
source-git-commit: dc1937169029c76dbce1ba513dd6430dffbc86c5
workflow-type: tm+mt
source-wordcount: '516'
ht-degree: 0%

---

# CAMPAIGN CLASSIC - [!UICONTROL 증분 쿼리] 새 레코드 대신 모든 레코드 선택

## 설명

고객에게 예상대로 작동하지 않는 몇 가지 증분 쿼리가 있습니다. 지난 경기 이후 신기록만 뽑지 않고 매번 정상과 같은 기록을 모두 뽑고 있다 [!UICONTROL 쿼리] 활동.

## 해결 방법

범인은 [!UICONTROL 정리] 워크플로입니다.

다음 [!UICONTROL 증분 쿼리] 워크플로우는 다음 방식으로 작동합니다.

1. 이전 이터레이션의 결과를 사용하여 기록 테이블을 유지합니다.
1. 대상 쿼리에서 모든 행을 가져옵니다.
1. 기록 테이블에 있는 모든 행 필터링
1. 나머지 결과를 다음 반복 필터링을 위해 기록 테이블에 추가합니다.

따라서 이 내역 작업 테이블 이름은 다음과 같은 표기법으로 지정됩니다.

*wkfhistoworkflowid* activityName_

이제 workflowIDs 0의 경우(다음의 경우) `xtknewid` 음수 시퀀스 허용). 실제로 다음과 같습니다.

*wkfhito(uint)workflowid* activityName_

워크플로우 실행에는 문제가 없지만,

예를 들어 증분 활동은 `incremental1` 워크플로우 ID=-1인 경우 테이블이 만들어집니다. `wkfhisto4294967295_incremental1`.

놓친 것은 [!UICONTROL 정리] 워크플로입니다.

여기에서는 삭제된 워크플로우의 작업표를 삭제하려는 코드가 있습니다.

여기에서 전용 코드는 모든 wkfhisto\* 테이블을 나열하고, 해당 이름(위의 규칙에서)에서 workflowId를 추출한 다음, xtkworkflow 테이블에서 worklowID를 찾은 테이블을 제외한 모든 테이블을 삭제합니다.

하지만 다음 항목이 누락됩니다. `uint` 부분.

따라서 다시 int로 캐스팅하는 대신 ID 4294967295이 있는 워크플로우를 검색하려고 합니다. 이 워크플로우를 찾을 수 없으므로 이 테이블이 삭제됩니다. 다음에 이 워크플로우가 실행될 때 [!UICONTROL 증분 쿼리] 활동은 기존 기록 테이블을 찾지 않으며 이를 사상 첫 실행으로 간주하여 만듭니다.

<b>수정:</b>

이 문제에 대한 수정 사항은 Adobe Campaign Classic 20.1.1 릴리스(빌드 9122 이상)에서 사용할 수 있습니다.

<b>고객이 사용할 수 있는 해결 방법:</b>

해결 방법 1: 정리 워크플로우를 중지하고 간헐적으로 실행하여 수정 사항을 적용하고 사용할 수 있을 때까지 데이터베이스 및 HDD를 정리합니다. 계획된 업그레이드가 없는 경우에는 권장되지 않습니다.

해결 방법 2: 다음과 같이 가정합니다. [!UICONTROL 증분 쿼리] 활동은 영향을 받으며 다음과 같은 작업을 수행하여 문제를 해결합니다. [!UICONTROL 증분 쿼리] 기록 테이블 컨텐츠를 보관할 영구 스키마를 생성하여 이 작업을 수행합니다. 다음을 조합하여 사용 [!UICONTROL 쿼리] 및 [!UICONTROL 데이터 업데이트] 동작을 모방하는 활동. 증분 쿼리가 필요한 모든 워크플로우에 대해 이 작업을 수행해야 합니다.

해결 방법 3: 다음과 같이 가정합니다. [!UICONTROL 증분 쿼리] 활동이 영향을 받으며 해당 스키마에 감사 필드(tsCreated/tsLastModified)를 추가하여 활동을 해결합니다. 그런 다음 증분 쿼리는 다음과 같은 where 절을 사용하는 일반 쿼리 활동으로 변환됩니다 `tscreated GetDate()`.

해결 방법 4:

- 새 시퀀스 xtknewworkflowid를 만들고 현재 workflowId 범위로부터 먼 시퀀스로 초기화합니다.
- 이 항목을 사용하려면 xtkworkflow 스키마를 변경하십시오. `pkSequence`
- 고객에게 영향을 받는 모든 워크플로우를 복제하고 원래 워크플로우를 삭제하도록 요청합니다.
- 고객이 업그레이드를 준비하면 (으)로 되돌려 이 수정 사항을 제거합니다. `xtknewId` (원치 않는 놀라움을 피하기 위해) 워크플로우 생성.
