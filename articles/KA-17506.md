---
title: Wireshark를 이용한 SMPP 프로토콜 분석
description: 설명
solution: Campaign
product: Campaign
applies-to: Campaign Classic
keywords: KCS, SMPP, Wireshark
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Craig Thonis
article-created-date: 5/6/2022 3:51:03 PM
article-published-by: Craig Thonis
article-published-date: 5/6/2022 3:52:19 PM
version-number: 4
article-number: KA-17506
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=9319e64e-54cd-ec11-a7b5-6045bd00d4f5
exl-id: 39c89da2-36ae-4c66-9553-cfc3d5b4003a
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '2545'
ht-degree: 1%

---

# Wireshark를 이용한 SMPP 프로토콜 분석

## 설명

<br>Wireshark를 사용하여 SMPP 트래픽을 분석하는 방법을 알아봅니다.<br><br><br><br><br>소개<br><br><br><br> <br><br>
대부분의 고속 SMS-C는 SMPP 프로토콜 버전 3.4와 호환됩니다. 이 프로토콜을 통해 SMS를 전송하고 이러한 SMS 게재에 대한 정보를 받을 수 있습니다. SMPP 프로토콜은 인터넷에서 PDF 문서로 사용할 수 있는 SMPP 프로토콜 사양 v3.4에 설명되어 있습니다.

이 문서는 다음 사양을 대체하지 않습니다. Adobe Campaign과 SMS-C 파트너 간의 문제를 해결하는 데 도움이 되도록 프로토콜 사양을 해석하고 Wireshark 디스플레이와 일치시키는 방법에 대한 실용적인 팁을 제공합니다.

SMPP 프로토콜에는 구현 팀의 해석으로 남아 있는 많은 부분이 포함되어 있으므로 서로 다른 SMS-C 간에 차이가 있습니다.

문제를 해결할 때 항상 SMS-C 파트너에게 문의하여 정보를 얻거나 받은 내용을 다시 확인하는 데 도움을 받으십시오. SMS-C가 오류와 함께 답장하는 경우, SMS-C 파트너가 오류와 함께 답장하는 이유를 가장 잘 알 수 있습니다. 실제 SMS-C에 연결하는 대신 SMPP 시뮬레이터를 사용하는 경우 소스 코드(또는 디버거)를 사용하여 일어나고 있는 작업을 파악해야 합니다.


## 해상도

<br><br>Wireshark 없이 네트워크 트래픽 캡처<br><br><br><br><br><br>
컴퓨터에 직접 액세스할 수 없는 경우 다음과 같은 명령줄 도구를 사용하여 캡처해야 할 수 있습니다 *tcpdump*. 연결의 TCP 포트를 이미 알고 있는 경우 모든 트래픽을 캡처하지 않도록 올바른 필터를 사용하십시오. 다음은 포트 12345을 캡처할 샘플 tcpdump 명령줄입니다. <b>outfile.pcap</b>:


| `tcpdump -i any -w outfile.pcap tcp port 12345` |
| --- |


파일 <b>outfile.pcap</b> 그런 다음 추가 분석을 위해 Wireshark에서 열 수 있습니다.


<br><br>마법사 처리<br><br><br><br> <br><br><br><br>
이 항목에서는 사용자가 Wireshark의 기본 사항을 잘 알고 있다고 가정합니다. 패킷 캡처, 단순 필터 정의, 패킷 세부 정보 읽기 에 대한 간단한 소개가 제공됩니다 [방법 - Wireshark를 사용하여 패킷 캡처, 필터링 및 Inspect 패킷을 사용하는 방법](https://www.howtogeek.com/104278/how-to-use-wireshark-to-capture-filter-and-inspect-packets/).

Wireshark에서 SMPP 트래픽을 필터링하려면 다음과 같은 세 가지 중요한 기능이 있습니다.

- SMS-C의 포트에서 표시 필터를 사용합니다. 예를 들어 SMS-C에서 포트 10000을 사용하는 경우에는 다음 필터를 사용하십시오.
   *tcp.port == 10000*


전화 번호나 텍스트 컨텐츠별로 패킷을 분리하려면 다음 설정을 사용하여 검색 기능을 사용하십시오.
![smpp1](https://helpx.adobe.com/content/dam/help/en/campaign/kb/smpp-protocol-wireshark/jcr_content/main-pars/image/smpp1.png "smpp1")
- 를 사용하십시오 <b>TCP 스트림 따라하기</b> 작업 중인 스트림을 격리하는 도구입니다.
SMPP와 관련이 없는 텍스트 프로토콜에만 유용하므로 나타나는 빨간색/파란색 텍스트 창을 닫습니다.
   ![smpp2](https://helpx.adobe.com/content/dam/help/en/campaign/kb/smpp-protocol-wireshark/jcr_content/main-pars/image_964579199/smpp2.png "smpp2")



<br><br><br><br>SMPP 프로토콜<br><br> <br><br>
프로토콜은 TCP에서 작동하며 완전히 이진법이며, 이는 Wireshark(또는 16진수 편집기)와 같은 특수 도구가 스트림의 내용을 해독하는 데 필요합니다.

스트림은 독립적인 PDU로 구성됩니다. 각 PDU는 명령, 상태, 시퀀스 번호 및 명령을 기반으로 하는 기타 정보를 포함하는 메시지입니다.

스트림 프로토콜로서의 TCP의 특성으로 인해 TCP 패킷은 둘 이상의 PDU를 포함할 수 있으며, PDU는 2개 이상의 TCP 패킷에 걸쳐 있을 수 있습니다. Wireshark는 PDU를 올바르게 재조합하므로 Wireshark 사용자가 주로 투명합니다.

다음은 MT를 보내고 SR을 받을 때 네트워크를 통해 전달되는 PDU의 예입니다.
![smpp3](https://helpx.adobe.com/content/dam/help/en/campaign/kb/smpp-protocol-wireshark/jcr_content/main-pars/image_388497282/smpp3.png "smpp3")
참고:

표준 명령 목록은 SMPP 사양(SMPP 명령 세트)의 섹션 5.1.2.1에서 찾을 수 있습니다.
<br><br><br><br><br><br>SMPP 응답<br><br><br><br> <br><br>
SMPP 프로토콜은 응답 PDU로 모든 명령을 인식해야 합니다.

BIND_TRANSMITTER가 *BIND_TRANSMITTER_RESP*, *SUBMIT_SM* 에 의해 인식됨 *SUBMIT_SM_RESP*&#x200B;등

응답에 대한 제한 시간이 있습니다. 일반적으로 10, 30 또는 60초입니다. 응답에는 긍정적 확인(명령 _status = 0) 또는 오류가 포함될 수 있습니다(5.1.3 참조) *command_status*, *표 5-2* ( 표준 오류 목록에 대한 SMPP 사양 참조). 대부분의 경우 이러한 응답이 즉시 응답되며 응답 시간 초과에 도달하지 않습니다.

SMPP 응답 오류와 SR 오류 코드를 구분해야 합니다. 동일한 오류 코드는 응답 오류 또는 SR 오류 필드의 다른 항목을 의미할 수 있습니다. 오류 코드를 보고할 때 값의 의미는 해당 컨텍스트에 따라 달라지므로 오류 코드를 찾은 위치를 주의해야 합니다.
<br><br><br><br><br><br>SMPP 연결 초기화<br><br><br><br><br><br>
SMPP 연결은 TCP를 사용하여 연결하여 시작됩니다. 그런 다음 BIND 작업이 캠페인에서 전송되며, BIND RESP로 인식됩니다. 이러한 작업은 SMPP 사양(BIND 작업)의 섹션 4.1에 설명되어 있습니다.
![smpp4](https://helpx.adobe.com/content/dam/help/en/campaign/kb/smpp-protocol-wireshark/jcr_content/main-pars/image_468626174/smpp4.png "smpp4")
바인딩 작업은 로그인/암호 확인을 수행하고 사양에 설명된 플랫폼 이름, 버전 및 기타 필드에 대한 정보를 교환합니다.

참고:

로그인은 system_id 필드에서 찾을 수 있습니다.



Campaign에서 *BIND_TRANSMITTER* MT 전송을 시작할 때 및 *BIND_RECEIVER* 패킷 *nlsm s* 은(는) MO/SR 연결을 트리거합니다.

<b>송신기, 수신기 및 송수신 장치: </b>Campaign Classic용 SMPP 커넥터는 별도의 송신기/수신기 모드에서 작동합니다. 두 개의 TCP 연결이 있으며, 하나는 MT를 전송하는 연결이고, 다른 하나는 MO와 SR을 수신하는 연결입니다. TCP 연결은 수신기 모드에 대해서도 항상 Campaign에서 시작됩니다.

SMPP는 또한 송수신 모드를 제공하지만 이 모드는 Campaign Classic용 SMPP 커넥터에서 구현되지 않습니다.

SMPP 커넥터는 여러 연결을 병렬로 사용하여 MT를 전송한다. 커넥터를 디자인하는 방식 때문에 제어할 수 없습니다.
<br><br><br><br><br><br>수신 MO<br><br><br><br><br><br>
수신기가 바인딩되면 SMS-C는 언제든지 MO를 전송할 수 있습니다. MO는 *DELIVERY_SM* 비트 2-5가 포함된 PDU *esm_clas s* 지우기(자주) *esm_class* 은 단순히 0입니다.
![smpp5](https://helpx.adobe.com/content/dam/help/en/campaign/kb/smpp-protocol-wireshark/jcr_content/main-pars/image_695769115/smpp5.png "smpp5")
다음 *DELIVERY_SM* PDU는 *DELIVERY_SM_RESP* 동일한 PDU *sequence_number*.
<br><br><br><br><br><br>MT 보내기<br><br><br><br><br><br>
MT를 보내려면 전송기가 성공적으로 바인딩되어야 합니다. 먼저 바인딩 프로세스가 성공적으로 수행되었는지 확인합니다.

MT는 *SUBMIT_SM* PDU. SMS-C는 *SUBMIT_SM_RESP* PDU: 이 응답 패킷은 SMS-C의 데이터베이스에 메시지 ID가 포함되어 있으므로 특별합니다(메시지를 더 빨리 찾을 수 있도록 SMS-C 파트너와 통신할 때 항상 이 ID를 포함하십시오). 이 ID는 SR에 있으며 MT를 해당 SR과 일치시키는 유일한 방법입니다.

필드 *register_delivery* (사양 5.2.17절에 설명)은 SMS-C에 SR이 특정 MT에 대해 요청되는지 여부를 나타냅니다. 특정 메시지에 대한 SR을 받지 않는 경우, *SUBMIT_SM* PDU.
![smpp5](https://helpx.adobe.com/content/dam/help/en/campaign/kb/smpp-protocol-wireshark/jcr_content/main-pars/image_1891077095/smpp5.png "smpp5")<br><br><br><br><br><br>MT 인코딩<br><br><br><br><br><br>
주의:

SMS 인코딩은 많은 트랩과 다양한 구현이 있는 복잡한 주제입니다.


<br><br><br><br> <br><br>
인코딩 문제가 발생할 경우 항상 SMS-C 파트너에게 문의하는 것이 좋습니다. SMS 파트너는 기술 플랫폼의 제한 사항으로 인해 적용될 수 있는 지원되는 인코딩 및 특수 규칙에 대한 정확한 지식을 보유하고 있습니다. 그들에게 보내는 것과 그들이 여러분에게 보내는 것을 확인하도록 하세요, 그것은 성공적이고 안정적인 상호연결을 위한 유일한 길입니다.

SMS 메시지는 GSM7 인코딩이라고 하는 특수 7비트 인코딩을 사용합니다. Wikipedia GSM 03.38(영어)을 참조하십시오.
<br><br><br><br> <br><br>
SMPP 프로토콜에서 GSM7 텍스트가 문자당 8비트로 확장되어 문제를 더 쉽게 해결할 수 있습니다. SMS-C는 모바일로 전송되기 전에 문자당 7비트로 묶습니다. 즉, SMS의 short_message 필드는 SMPP 프레임에서 최대 160바이트의 길이가 될 수 있지만 모바일 네트워크에서 전송할 때는 140바이트로 제한됩니다(가장 중요한 비트는 삭제됨).

인코딩 문제가 발생하면 확인할 몇 가지 중요한 사항이 있습니다.

- 먼저 어떤 문자가 어떤 인코딩에 속하는지 알아야 합니다. GSM7은 분음 부호(악센트)를 부분적으로 지지하는 것으로 악명 높습니다. 특히 프랑스어로, é와 는 GSM7의 일부이지만, 혹은 그렇지 않습니다. 스페인어라면 사정이 더 좋지 않다.
- GSM7 알파벳의 경우 C(cedilla)가 있는 경우에는 대문자만 표시되지만, 일부 휴대폰은 소문자 또는 &quot;smart&quot; 케이스에서 렌더링됩니다. 일반적으로 이러한 문제를 완전히 방지하고, cedilla(프랑스어로 여전히 읽을 수 있음)를 제거하거나 UCS-2로 전환하는 것이 좋습니다.
- SMS-C 파트너가 명시적으로 요청하지 않는 한 SMS에서 ASCII를 사용하지 마십시오. 이 인코딩은 GSM7보다 8비트 문자를 사용하고 적용 범위가 적으므로 공간을 낭비합니다.
- Latin-1은 항상 지원되지 않습니다. Latin-1을 사용하기 전에 SMS-C 파트너와 호환성을 확인하십시오.
- 국가 언어 이동 표는 Adobe Campaign Classic 커넥터에서 지원하지 않습니다. 대신 UCS-2를 사용해야 합니다.
- UCS-2와 UTF-16이 종종 휴대폰에 의해 혼합됩니다. 이는 UCS-2에 없는 이모지와 거의 사용되지 않는 문자를 보내는 사람들에게 문제가 됩니다.
- GSM7 인코딩은 Wireshark에서 지원하지 않습니다. 특수 문자가 잘못 표시됩니다. GSM7 문자열이 제대로 인코딩되어 있는지 확인해야 하는 경우 16진수 코드를 GSM7 테이블과 비교해야 합니다.


다음 *data_coding* 필드는 사용할 인코딩을 알려줍니다. 유일한 문제는 값 0이 사양에 있는 기본 SMS-C 인코딩을 의미하지만 일반적으로 GSM7을 의미한다는 것입니다. SMS-C로 확인 *partner data_coding = 0(Adobe Campaign은 data_coding에 대해서만 GSM7을 지원합니다.* = 0).

메시지의 최대 크기는 인코딩에 따라 다릅니다. 이 표에서는 모든 관련 정보를 요약합니다.
<br><br><br><br> <br>

| 인코딩 | data_coding | 메시지 크기(문자)  | 다중 부분 SMS의 부품 크기  | 사용 가능한 문자  |
| --- | --- | --- | --- | --- |
| GSM7 | 0 | 160 | 152 | [GSM7 기본 문자 세트 + 확장](https://en.wikipedia.org/wiki/GSM_03.38) (확장 문자는 2자)  |
| 라틴-1  | 3 | 140 | 134 | ISO-8859-1 |
| UCS-2 UTF-16  | 8 | 70 | 67 | 유니코드(전화마다 다름) |

<br><br><br><br><br>사용자 데이터 헤더(UGH)<br><br><br><br><br><br>
UGH(사용자 데이터 헤더)는 SMS 텍스트에 추가된 작은 바이너리 헤더입니다. SMS 연결, 국가 언어 작업 표, 로고/이미지(거의 사용되지 않음) 또는 WAP 푸시와 같은 특수 기능을 트리거할 수 있습니다.

UGH는 텍스트 필드(short_message SMPP 필드)의 일부이므로 SMS의 유효한 크기를 줄입니다. 예를 들어 연결된 SMS UGH는 SMS 부분당 6바이트(실제 8비트, 7비트 문자는 아님)를 소비하며 메시지 부분당 152개의 7비트 문자만 사용할 수 있습니다.

Wikipedia에는 사용자 데이터 헤더와 연결된 SMS(영어)에 대한 좋은 문서가 있습니다.

short_message에 UGH가 포함되어 있는지 확인하려면 esm_class의 비트 6 및 7을 확인하십시오(세부 항목의 섹션 5.2.12 참조). Wireshark는 인터페이스에서 UGH를 구문 분석하여 정확한 정보를 제공합니다.
![smpp7](https://helpx.adobe.com/content/dam/help/en/campaign/kb/smpp-protocol-wireshark/jcr_content/main-pars/image_738682084/smpp7.png "smpp7")
위의 스크린샷에서는 메시지 필드(1)의 사용자 데이터 헤더, UGH(2)에 포함된 정보 및 패킷에 속하지 않고 Wireshark(3)에 의해 계산되는 일부 추가 정보를 볼 수 있습니다. 짧은 메시지 본문 필드는 Wireshark가 재구성한 전체 메시지를 포함하고 있기 때문에 특히 흥미롭습니다.
<br><br><br><br><br><br>수신 SR<br><br><br><br><br><br>
수신기가 바인딩되면 SMS-C는 언제든지 SR을 전송할 수 있습니다. SR은 비트 2-5와 함께 DELIVERY_SM PDU를 사용하여 전송됩니다 *esm_class*설정합니다.
![smpp8](https://helpx.adobe.com/content/dam/help/en/campaign/kb/smpp-protocol-wireshark/jcr_content/main-pars/image_158644074/smpp8.png "smpp8")
다음 *DELIVERY_SM* PDU는 *DELIVERY_SM_RESP* 동일한 PDU *sequence_number*. 이 SR과 일치하는 MT를 찾으려면 *SUBMIT_SM_RESP* 를 반환합니다. 예를 들어 SR과 일치하는 MT입니다.
![smpp9](https://helpx.adobe.com/content/dam/help/en/campaign/kb/smpp-protocol-wireshark/jcr_content/main-pars/image_1012110897/smpp9.png "smpp9")
SR은 *register_delivery* 필드는 MT에 설정되어 있습니다.

참고:

Adobe Campaign Classic SMPP 커넥터는 *SUBMIT_SM_RESP* 패킷 을 참조하십시오. 사양은 이 동작을 명시적으로 금지하지 않지만 잘못된 동작으로 간주됩니다(메시지를 보내기 전에 메시지를 수신했음을 의미합니다.). 이 문제가 너무 자주 발생하는 경우 SMS-C 파트너에게 이 플랫폼을 수정하도록 요청하십시오.
<br><br><br><br><br><br>SR의 short_message 필드 해석<br><br><br><br><br><br>
SR PDU의 텍스트 필드에는 SMPP 프로토콜 사양의 부록 B에 설명된 특수 인코딩이 있습니다. 안타깝게도 이 형식은 대부분의 SMS-C가 이 형식을 거의 준수하지 않지만 프로토콜에 속하지 않는 추천입니다.

직접 SMS-C 파트너에게 자체 구현 설명서를 문의하고 Wireshark에 표시되는 내용과 일치하는지 다시 확인해야 합니다. 특히 SMS-C 구현자는 구현도 잘 모르고 이로 인해 문제와 오해가 발생하는 경우가 많습니다. 이 필드(특히 오류 코드)에 대한 의심이 있는 경우 SMS-C 파트너에게 도움을 요청하십시오.

기본 형식은 다음과 같습니다.

*id:IIIIIIIIII 하위:SSS dlvrd:DDD 제출 날짜:YYMDDhhhhmm done 날짜:YYMDDhhhmm:DDDD 오류:EEE*

*텍스트:........*

다음은 위의 행을 읽는 일반적인 지침입니다.

- ID는 *SUBMIT_SM_RESP*&#x200B;일치하는 MT
- 텍스트 필드의 문제를 무시할 수 있습니다. 이 필드는 사용이 불가능하고 신뢰할 수 없으므로 Campaign에서 무시되며, 순수한 영숫자 ASCII가 아닌 다른 인코딩을 사용하여 SMS를 보낸 경우 읽을 수 없을 수도 있습니다. 이는 정상적인 동작입니다.
- 필드 이름은 대/소문자를 구분하지 않습니다(예: id: 하위: 텍스트: 는 ID로 기록할 수도 있습니다. 하위: 텍스트:)
- 다음 *dlvrd* SMS-C 파트너가 명시하지 않는 한 필드는 일반적으로 신뢰할 수 없습니다.
- 날짜가 시간대를 가지고 있어 사실상 쓸모가 없거나 원격 서버의 시계가 꺼져 있기 때문에 잘못된 날짜입니다.
- 다음 *stat*&#x200B;필드에는 부록 B에 정의된 값 이외의 다른 값이 있을 수 있습니다. 상식과 SMSC 파트너의 설명서를 사용하여 의미를 파악합니다.
- 다음 *오류*&#x200B;필드는 SMS-C에 완전히 의존하며 SMS-C 파트너가 문서화한 대부분의 시간을 사용합니다. 종종 코드 000은 성공을 의미하지만, 다른 코드는 오류를 나타냅니다. 필드는 종종 숫자이지만 16진수일 수도 있습니다.

<br><br><br><br><br><br>동일한 MT용 다중 SR<br><br><br><br><br><br>
일부 SMS-C는 네트워크에서 MT 진행 상황을 추적하기 위해 동일한 MT에 대해 여러 SR을 보냅니다. 이는 대부분의 경우 클라이언트가 메시지가 수신된 시기(일반적으로 마지막 SR)만 알고 싶어하기 때문에 사용하지 않는 것입니다.

확실하지 않은 경우 SMS-C에서 수신한 최신 SR에서만 메시지 상태를 확인할 수 있습니다.
<br><br><br><br><br><br>SMPP 창<br><br><br><br><br><br>
작업 및 응답은 비동기이므로 응답을 기다리기 전에 여러 작업 PDU를 전송하여 전송 속도를 최적화할 수 있습니다. 응답이 없는 메시지 수를 창이라고 합니다.

최대 창이 4인 전송 예:
![smpp10](https://helpx.adobe.com/content/dam/help/en/campaign/kb/smpp-protocol-wireshark/jcr_content/main-pars/image_2072040949/smpp10.png "smpp10")
현재 구현에서는 창을 제어하지 않으며 원격 SMS-C가 MT를 처리할 수 있을 만큼 빠를 것으로 예상됩니다.
