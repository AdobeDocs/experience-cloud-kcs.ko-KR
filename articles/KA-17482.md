---
title: "메모리 문제 분석"
description: 설명
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager"
keywords: "KCS"
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Roxann McGlumphy
article-created-date: "10/21/2021 5:18:56 PM"
article-published-by: Roxann McGlumphy
article-published-date: "10/21/2021 5:21:24 PM"
version-number: 1
article-number: KA-17482
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ef6bccf5-9232-ec11-b6e5-000d3a5ba97a"
exl-id: 48e49bcc-3d49-464e-8af9-e4292b1d6899
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '888'
ht-degree: 1%

---

# 메모리 문제 분석

## 설명

<br>증상<br><br>
Java 응용 프로그램은 더 느리게 실행되며 마지막으로 메모리가 부족하거나 로그 또는 콘솔 출력에 오류가 표시됩니다 `OutOfMemoryError: Java heap space` 또는 `OutOfMemoryError: gc overhead limit exceeded`.
<br><br>원인<br><br>
그러한 문제들은 많은 원인들을 가질 수 있다.

한 가지 가능한 원인은 Java 응용 프로그램이 명령줄에서 Java의 기본 heap 메모리 설정을 사용하여 CRX/CQ가 시작되었기 때문입니다. 즉, jvm 매개 변수가 `-Xmx` 이(가) 지정되지 않았습니다. CRX 또는 CQ는 적어도 256MB의 힙이 실행되어야 합니다. 문제가 발생하면 명령줄에서 시작하여 heap memory 설정이 설정되어 있는지 확인하십시오. 예:


```
java -Xmx512m -jar *.jar
```


그렇지 않으면 애플리케이션이 가비지 수집을 위해 객체를 해제하지 않고 너무 많은 객체를 유지할 수 있습니다. 이것은 메모리 누출이라고 합니다. [여기](http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html) 추가 정보. Java 응용 프로그램에서 메모리 문제를 분석하는 방법에 대해서는 아래 섹션을 참조하십시오.


## 해상도

더미 덤프 만들기<br><br>자동으로 더미 덤프 생성<br><br>
메모리가 부족한 상태에서 힙을 자동으로 만들려면 jvm 매개 변수를 추가할 수 있습니다 `-XX:+HeapDumpOnOutOfMemoryError` 응용 프로그램에서 OutOfMemoryError를 발생시킬 때 자동으로 힙덤프를 생성합니다. 예,


```
java -Xmx256m -XX:+HeapDumpOnOutOfMemoryError -jar *.jar
```


이렇게 하면 heap 덤프 파일(`java_...hprof`)을 입력합니다. 힙이 생성된 후에도 프로세스를 계속 실행할 수 있습니다. 일반적으로 한 개의 더미 덤프 파일이 문제를 분석할 수 있습니다.

<b>참고:</b> 사용 중인 `crx-quickstart/server/start` 스크립트를 사용하여 CRX 인스턴스를 시작하면 다음을 추가할 수 있습니다. `-XX:+HeapDumpOnOutOfMemoryError` 변환 후 `CQ_JVM_OPTS` 변수(변수에도 주석을 달 수 있는지 확인합니다.) 예:


```
CQ_JVM_OPTS='-XX:+HeapDumpOnOutOfMemoryError'
```


이 매개 변수를 추가하고 CRX 인스턴스를 다시 시작한 후 새 jvm 옵션이 설정되어 있는지 확인합니다. 실행 `ps -ef | grep java` 명령줄에서 을(를) 클릭합니다. 그런 다음 `-XX:+HeapDumpOnOutOfMemoryError` CRX java 프로세스의 매개 변수로 사용됩니다.

디스크 공간 제한으로 인해 힙덤프를 생성하기 위해 다른 디렉토리를 지정해야 하는 경우 `-XX:HeapDumpPath=/path/to/generate/heapdump` 매개 변수를 사용하여 파일을 넣을 jvm을 지정합니다.

자세한 내용은 [여기](http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions) 관련 jvm 매개 변수 디버깅에 대한 참조.
<br><br>수동으로 더미 덤프 생성<br><br>
<b>Sun/Oracle JVM</b>

힙덤프를 수동으로 생성하려면 이 명령(jmap 및 jps는 `bin` jdk 홈 디렉토리의 폴더):

1. 힙덤프를 생성하는 java 프로세스의 pid를 찾습니다.
   - Unix 또는 Linux에서 이 작업은 `ps -ef | grep java` 또는 `jps -l`
   - Windows에서는 작업 관리자를 열어 이 작업을 수행할 수 있습니다. `Ctrl+Shift+Esc` 그런 다음 <b>보기</b> = <b>열 선택</b> = <b>PID(프로세스 식별자)</b> 또는 `jps -l`
2. 아래의 jmap 명령을 실행하고 를 바꿉니다. `/path/to/generate/heapdumpfile.hprof` heap 덤프 파일을 생성할 위치로 바꾸고 `1234` 이전 단계에서 올려본 pid로.

   ```
   jmap -dump:format=b,file=/path/to/generate/heapdumpfile.hprof 1234
   ```


<b>IBM JVM</b>

먼저 사용자 신호에 대한 올바른 덤프를 생성하기 위해 덤프 에이전트에 대한 기본 JVM 설정을 변경해야 합니다. 여러 종류의 덤프가 있지만, 일반적으로 전체 덤프가 필요합니다 <b>시스템 덤프</b> 철저한 메모리 분석을 수행합니다. 다음 인수를 추가합니다.

<b>Xdump:heap:opts=PHD+CLASSIC:events=user -Xdump:system:events=user</b>

JVM이 운영 체제에서 SIGQUIT(Linux, AIX®, z/OS® 및 i5/OS™) 또는 SIGBREAK(Windows) 신호를 수신할 때 발생하는 &quot;사용자&quot; 이벤트입니다.

자세한 내용은 공급업체 설명서를 참조하십시오 [여기](http://pic.dhe.ibm.com/infocenter/java7sdk/v7r0/index.jsp?topic=%2Fcom.ibm.java.aix.70.doc%2Fdiag%2Fpreface%2Fchanges_70%2Foverview_gc.html).

<b>경고:</b> heap 덤프 파일은 크기가 크고 최대 heap -Xjvm 매개 변수 구성과 동일한 디스크 크기일 수 있습니다. 덤프 파일이 생성된 디렉토리에 디스크 공간이 충분한지 확인합니다.
<br><br>heap 덤프 분석<br><br>
heap 덤프를 분석하는 데 유용한 도구는 EclipseMAT(Eclipse Memory Analyzer)입니다. [http://www.eclipse.org/mat/](http://www.eclipse.org/mat/)

이 도구를 분석할 수 없습니다. <b>IBM JVM</b> 덤프 생성. 그러한 경우, 몇 가지 가능성이 있습니다. [IBM HeapAnalyzer](https://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=4544bafe-c7a2-455f-9d43-eb866ea60091) 는 힙이 PHD 또는 클래식 형식으로 덤프할 때 잘 작동합니다.

전체 시스템 덤프 분석의 경우 [IBM 지원 Workbench](http://www-01.ibm.com/software/support/isa/) , 사용 [IBM Java용 모니터링 및 진단 도구 - 메모리 분석기 버전 1.2](http://www.ibm.com/developerworks/java/jdk/tools/memoryanalyzer/) 가 설치되어 있습니다.
<br><br>히스토그램 히스토그램<br><br>
heap 히스토그램은 Java 클래스당 사용되는 라이브 개체 및 메모리 수를 간단하게 측정합니다. 안타깝게도 Java 설치에 따라 필요한 도구를 사용할 수 없거나 도구가 항상 작동하지 않을 수 있습니다. heap 히스토그램을 만들려면 먼저 Java 프로세스의 프로세스 ID가 필요합니다. 그걸 얻으려면 `ps` 또는 (사용 가능한 경우)를 실행합니다.


```
jps -l
```


이 Java 도구는 실행 중인 모든 Java 프로세스의 프로세스 ID를 가져옵니다. 예:


```
327 
3332 sun.tools.jps.Jps
3313 crx-quickstart-....jar
```


이제 다음 명령을 실행합니다.


```
jmap -histo 3313
```


필요한 총 메모리(약식: 참조된 개체를 제외하는 중입니다. 출력의 처음 20선이 가장 재미있다. 출력 예:


```
JVM version is 1.5.0_20-141
Iterating over heap. This may take a while...
Warning: skipping invalid TLAB for thread t@62211
Warning: skipping invalid TLAB for thread t@62467
...
SizeCountClass description
-------------------------------------------------------
1059290412916byte
1028584075255* ConstMethodKlass
628317658388char
604230414928int
4995752116201* SymbolKlass
422089675255* MethodKlass
41965126969* ConstantPoolKlass
29285606969* InstanceKlassKlass
26310086066* ConstantPoolCacheKlass
2395872149742org.apache.jackrabbit.core.query.lucene.DocId$PlainDocId
14760087003java.util.HashMap$Entry
139612858172java.lang.String
107023244593java.util.HashMap$Entry
75398410036short
73546454org.apache.jackrabbit.core.query.lucene.DocId
7201927502java.lang.Class
64070413348com.day.crx.persistence.tar.index.IndexEntry
...
```


<b>추가 정보</b>

문제를 분석하는 데 도움이 되도록 다음 정보를 알고 있어야 합니다.

- 설치된 모든 핫픽스 버전 번호의 목록을 포함하는 CRX 또는 CQ 버전입니다.
- 운영 체제, JVM 공급업체 및 버전입니다.


<b>참조</b>

1 [http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html](http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html)
2개 [http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions](http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions)
