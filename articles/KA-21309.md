---
title: "request.log 분석 예 | AEP"
description: 설명
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager"
keywords: "KCS, AEP, 요청 로그"
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Amol Mahajan
article-created-date: "1/31/2023 11:02:06 AM"
article-published-by: Amol Mahajan
article-published-date: "1/31/2023 11:32:45 AM"
version-number: 3
article-number: KA-21309
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=f8c6eab1-56a1-ed11-aad1-6045bd0067ea"
source-git-commit: 1bb94ae378ff9bc9be605499bb222790e4aea393
workflow-type: tm+mt
source-wordcount: '968'
ht-degree: 95%

---

# request.log 분석 예 | AEP

## 설명 {#description}

<b>환경</b>
Experience Manager 6.5


<b>문제/증상</b>
Adobe Experience Manager(AEM) `request.log` 성능 문제를 분석하는 데 사용되는 응답 시간과 같은 다양한 유용한 정보를 포함합니다. 다음은 Linux 명령(일부 외부 명령 포함)을 사용한 분석 예제의 목록입니다.




## 해결 방법 {#resolution}

<b>목차:</b>
소개
  request.log의 형식

준비 단계

1. 데이터 정리
2. 재실행 시간
3. 시간당 액세스 수
4. 최대 동시 처리
5. 로그 파일 분할
6. 요청 레코드와 응답 레코드 병합




분석 예

1. 가장 많은 액세스
2. 누락된 응답에 대한 액세스
3. 느린 액세스
4. 응답 시간의 시계열 데이터
5. 최소, 평균, 중앙값, 최대 응답 시간
6. 기간별 액세스 수
7. 기간별 응답 상태 수
8. 가장 자주 사용되는 URL
9. request.log 레코드에 대한 access.log 레코드


결론

<b>소개</b>



<u>request.log의 형식</u>

기본적으로 AEM 6.5는 다음 형식으로 request.log를 생성합니다. 시스템 제한으로 인해 해당 문서의 명령줄은 일반 텍스트 대신 이미지로 표시됩니다.

request.log의 예:
![](assets/e51bfd97-dd9b-ed11-aad1-6045bd006793.png)



이 문서에서는 “-”가 포함된 줄을 “요청 레코드”라고 합니다. “-”가 포함된 줄은 “응답 레코드”입니다.

요청 레코드
  AEM에서 요청을 받으면 요청 레코드가 기록됩니다. 해당 기록에는 수신 날짜와 시간, 요청 ID, 요청 방법 및 URL이 포함됩니다.

응답 레코드
  AEM에서 요청에 응답하면 응답 레코드가 기록됩니다. 해당 기록에는 응답 날짜 및 시간, 요청 ID, 상태 코드, 콘텐츠 유형 및 응답 시간(밀리초)이 포함됩니다.

해당 설명서도 참조하십시오.
https://experienceleague.adobe.com/docs/experience-manager-65/deploying/configuring/monitoring-and-maintaining.html?lang=en#interpreting-the-request-log

<b>준비 단계:</b>



<u>1단계. 데이터 정리</u>

request.log 분석을 시작하기 전에 로그 레코드를 표준화하는 것이 중요합니다.

![](assets/2a1adef4-dd9b-ed11-aad1-6045bd006793.png)



첫 번째 sed 명령은 공백으로 잘못된 필드 구분을 방지하기 위해 응답 레코드의 콘텐츠 유형에서 추가 공백을 제거합니다. ruby 명령은 날짜 형식을 ISO 8601로 변환합니다. 또한 ruby 명령은 콜론 대신 공백으로 날짜와 시간을 구분합니다.

<u>2단계. 재실행 시간</u>

AEM 및 서비스 팩 설치를 다시 시작하면 request.log의 요청 ID가 재설정됩니다. 요청 ID = 0인 요청 레코드는 이러한 종류의 작업이 있을 수 있음을 나타냅니다.

![](assets/777fcc1e-de9b-ed11-aad1-6045bd006793.png)



위의 예에서는 요청 ID는 13:08:49 및 13:26:13에서 0으로 재설정되었습니다.

<u>3단계. 시간당 액세스 수</u>

시간당 액세스 수와 request.log의 시간 범위를 계산합니다.

![](assets/712fae49-de9b-ed11-aad1-6045bd006793.png)



<u>4단계. 최대 동시 처리</u>

동시 처리 수는 AEM의 서버 부하를 추측하는 데 도움이 됩니다.

![](assets/7b359b5c-de9b-ed11-aad1-6045bd006793.png)



기본적으로 AEM에서 Jetty에 대한 최대 동시 연결 수는 200으로 설정됩니다. 응답을 완료한 후 소켓을 릴리스하는 데 지연이 있습니다. 동시 처리 수가 약 170을 초과하면 새로운 요청을 수락할 수 없게 됩니다.

<u>5단계. 로그 파일 분할</u>

request.log의 요청 ID는 AEM이 다시 시작되거나 서비스 팩이 설치될 때 재설정됩니다. 이러한 동작으로 인해 request.log에 해당 작업이 포함된 경우 분석이 정확하지 않을 수 있습니다. 정확한 분석을 수행하고 한 번에 처리하는 파일의 크기를 줄이기 위해 요청 ID = 0인 요청 레코드를 사용하여 request.log를 분할합니다.

![](assets/a342906e-de9b-ed11-aad1-6045bd006793.png)



<u>6단계. 요청 레코드와 응답 레코드 병합</u>

요청 ID별로 요청 및 응답 레코드를 병합하면 성능 문제가 시작된 시점을 보다 쉽게 파악할 수 있습니다. 이후 예제에서 이 병합된 로그 파일을 사용해 보겠습니다.

![](assets/e3848b8c-de9b-ed11-aad1-6045bd006793.png)



마지막 sed 명령은 상응하는 응답 레코드가 없는 요청 레코드에 더미 응답을 추가합니다. 요청 레코드가 없는 응답 레코드도 있을 수 있습니다. 그러나 해당 레코드는 일반적으로 조사 대상이 아니므로 무시할 수 있습니다.

병합된 로그 파일은 다음과 같습니다.

![](assets/79f3829e-de9b-ed11-aad1-6045bd006793.png)



<b>분석의 예</b>



<u>예제 1. 가장 많은 액세스</u>

응답 없는 액세스를 포함하여 병합된 로그 파일을 응답 시간별로 내림차순으로 정렬합니다.

![](assets/50d9b9da-de9b-ed11-aad1-6045bd006793.png)



<u>예제 2. 누락된 응답에 대한 액세스</u>

더미 응답 시간을 사용하여 해당 응답 레코드가 누락된 액세스를 추출합니다.

![](assets/7bf0beed-de9b-ed11-aad1-6045bd006793.png)



응답 없이 액세스를 수신하는 타이밍이 서버 부하의 증가와 관련이 있는 경우 이러한 액세스로 인해 성능 문제가 발생할 수 있습니다.

![](assets/4c86bdff-de9b-ed11-aad1-6045bd006793.png)



<u>예제 3. 느린 액세스</u>

10초 이상 소요된 액세스를 추출합니다.

![](assets/028e0518-df9b-ed11-aad1-6045bd006793.png)



히트 수가 너무 많은 경우 grep 명령에서 0-9{5}를 0-9{6}로 교체하여 100초 이상 소요되는 액세스로 범위를 좁힙니다.

<u>예제 4. 응답 시간의 시계열 데이터</u>

데이터에서 타임스탬프와 응답 시간만 추출하면 그래프를 만드는 데 유용하게 활용할 수 있습니다.

![](assets/e200d731-df9b-ed11-aad1-6045bd006793.png)



즉시 응답한 액세스를 생략하면 데이터의 효율성이 향상됩니다. 다음 예제는 1초 이상 소요된 액세스를 추출합니다.

![](assets/ec4bd13d-df9b-ed11-aad1-6045bd006793.png)



<u>예제 5. 최소, 평균, 중앙값, 최대 응답 시간</u>



![](assets/523f6d50-df9b-ed11-aad1-6045bd006793.png)



위의 예에서는 통계 처리를 위해 datamash 명령(https://www.gnu.org/software/datamash/)을 사용합니다. 로그에 응답 없는 액세스가 포함된 경우 더미 값이 결과에 영향을 미칩니다.

<u>예제 6. 기간별 액세스 수</u>

10분당 액세스 수를 계산합니다. 산출된 결과는 볼륨이 큰 트래픽이 성능 문제를 유발했는지 확인하는 데 도움이 됩니다.

![](assets/16ffe970-df9b-ed11-aad1-6045bd006793.png)



다음 예에서는 데이터의 범위를 POST 요청으로만 좁힙니다. 일반적인 사용 사례는 게시 계층에 콘텐츠 작성 또는 복제가 집중되어 있는지 확인하기 위한 것입니다.

![](assets/9447dd7c-df9b-ed11-aad1-6045bd006793.png)



<u>예제 7. 기간별 응답 상태 수</u>

datamash 명령을 사용하여 10분당 각 응답 상태 수를 나타내는 테이블을 작성합니다.

![](assets/8a91d788-df9b-ed11-aad1-6045bd006793.png)



<u>예제 8. 가장 자주 사용되는 URL</u>

10분마다 가장 자주 액세스된 상위 3개의 URL을 인쇄합니다.

![](assets/a04efc9a-df9b-ed11-aad1-6045bd006793.png)



<u>예제 9. request.log 레코드에 대한 access.log 레코드</u>

특정 요청 ID에 상응하는 레코드에 대한 access.log를 검색합니다.

![](assets/891a02ad-df9b-ed11-aad1-6045bd006793.png)



동일한 URL에 대한 여러 액세스가 동시에 발생한 경우 결과에는 단일 요청 ID에 대한 여러 access.log 레코드가 표시됩니다.

<b>결론</b>

이 문서의 예제가 성능 문제를 분석하는 데 도움이 되기를 바랍니다.

나열된 예제는 CentOS 7.5 및 Ubuntu 22.04LTS에서 테스트되었지만 다른 버전이나 명령의 변형과 같은 사용자의 환경에 따라 예상대로 작동하지 않을 수 있습니다. 환경에 설치된 명령에 따라 조정하시기 바랍니다.


